{"version": 2, "width": 80, "height": 24, "timestamp": 1756235056, "env": {"SHELL": "/bin/zsh", "TERM": "tmux-256color"}}
[0.651077, "o", "Output saved to: /Users/peter.souter/.claude-squad/worktrees/add-ascii-cinema-to-readme_185f63a06ded4048/petems-gh-pr-rev-md-20250826-200417-pr6.md\r\n"]
[0.707263, "o", "-rw-r--r--@ 1 peter.souter  staff  7862 26 Aug 20:04 petems-gh-pr-rev-md-20250826-200417-pr6.md\r\n"]
[0.713651, "o", "# petems/gh-pr-rev-md - PR #6 Review Comments\r\n**Repository:** petems/gh-pr-rev-md\r\n**Pull Request:** https://github.com/petems/gh-pr-rev-md/pull/6\r\n**Total Comments:** 2\r\n\r\n---\r\n\r\n## Comment #1\r\n**Author:** @github-advanced-security\r\n**File:** `gh_pr_rev_md/github_client.py`\r\n**Line:** 70\r\n**Created:** 2025-08-26 19:00:20 UTC\r\n\r\n### Code Context\r\n```diff\r\n@@ -13,19 +14,62 @@\r\n class GitHubClient:\r\n     \"\"\"Client for interacting with GitHub API.\"\"\"\r\n \r\n-    def __init__(self, token: Optional[str] = None):\r\n+    def __init__(self, token: Optional[str] = None, *, max_retries: int = 3, backoff_factor: float = 0.5):\r\n+        \"\"\"Initialize client.\r\n+\r\n+        Args:\r\n+            token: GitHub token\r\n+            max_retries: Number of attempts for transient failures (>=1)\r\n+            backoff_factor: Base seconds for exponential backoff; set 0 in tests\r\n+        \"\"\"\r\n         self.token = token\r\n         self.graphql_url = \"https://api.github.com/graphql\"\r\n         self.session = requests.Session()\r\n+        se"]
[0.713748, "o", "lf._max_retries = max(1, int(max_retries))\r\n+        self._backoff_factor = float(backoff_factor)\r\n         headers: Dict[str, str] = {\r\n-            \"Accept\": \"application/vnd.github.v3+json\",\r\n+            \"Accept\": \"application/vnd.github+json\",\r\n             \"X-GitHub-Api-Version\": \"2022-11-28\",\r\n             \"User-Agent\": \"gh-pr-rev-md\",\r\n         }\r\n         if token:\r\n-            headers[\"Authorization\"] = f\"bearer {token}\"\r\n+            headers[\"Authorization\"] = f\"Bearer {token}\"\r\n         self.session.headers.update(headers)\r\n \r\n+    # --- Internal helpers ---\r\n+    def _sleep_backoff(self, attempt: int) -> None:\r\n+        if self._backoff_factor <= 0:\r\n+            return\r\n+        delay = self._backoff_factor * (2 ** (attempt - 1))\r\n+        time.sleep(min(delay, 8.0))\r\n+\r\n+    def _should_retry(self, status_code: Optional[int], exc: Optional[Exception]) -> bool:\r\n+        if exc is not None:\r\n+            return isinstance(exc, (requests.Timeout, requests.ConnectionError))\r\n+        if status_co"]
[0.713759, "o", "de is None:\r\n+            return False\r\n+        return status_code == 429 or 500 <= status_code < 600\r\n+\r\n+    def _post_graphql(self, payload: Dict[str, Any]) -> requests.Response:\r\n+        last_exc: Optional[requests.RequestException] = None\r\n+        last_resp: Optional[requests.Response] = None\r\n+        for attempt in range(1, self._max_retries + 1):\r\n+            try:\r\n+                resp = self.session.post(self.graphql_url, json=payload, timeout=30)\r\n+                last_resp = resp\r\n+                if not self._should_retry(resp.status_code, None):\r\n+                    return resp\r\n+            except requests.RequestException as e:\r\n+                last_exc = e\r\n+                if not self._should_retry(None, e):\r\n+                    raise\r\n+            if attempt < self._max_retries:\r\n+                self._sleep_backoff(attempt)\r\n+        if last_resp is not None:\r\n+            return last_resp\r\n+        assert last_exc is not None\r\n```\r\n\r\n### Comment\r\nUse of assert detected. The enclose"]
[0.713854, "o", "d code will be removed when compiling to optimised byte code.\r\n\r\n[Show more details](https://github.com/petems/gh-pr-rev-md/security/code-scanning/22)\r\n\r\n---\r\n\r\n## Comment #2\r\n**Author:** @gemini-code-assist\r\n**File:** `gh_pr_rev_md/github_client.py`\r\n**Line:** 71\r\n**Created:** 2025-08-26 19:01:55 UTC\r\n\r\n### Code Context\r\n```diff\r\n@@ -13,19 +14,62 @@\r\n class GitHubClient:\r\n     \"\"\"Client for interacting with GitHub API.\"\"\"\r\n \r\n-    def __init__(self, token: Optional[str] = None):\r\n+    def __init__(self, token: Optional[str] = None, *, max_retries: int = 3, backoff_factor: float = 0.5):\r\n+        \"\"\"Initialize client.\r\n+\r\n+        Args:\r\n+            token: GitHub token\r\n+            max_retries: Number of attempts for transient failures (>=1)\r\n+            backoff_factor: Base seconds for exponential backoff; set 0 in tests\r\n+        \"\"\"\r\n         self.token = token\r\n         self.graphql_url = \"https://api.github.com/graphql\"\r\n         self.session = requests.Session()\r\n+        self._max_retries = max(1, i"]
[0.713992, "o", "nt(max_retries))\r\n+        self._backoff_factor = float(backoff_factor)\r\n         headers: Dict[str, str] = {\r\n-            \"Accept\": \"application/vnd.github.v3+json\",\r\n+            \"Accept\": \"application/vnd.github+json\",\r\n             \"X-GitHub-Api-Version\": \"2022-11-28\",\r\n             \"User-Agent\": \"gh-pr-rev-md\",\r\n         }\r\n         if token:\r\n-            headers[\"Authorization\"] = f\"bearer {token}\"\r\n+            headers[\"Authorization\"] = f\"Bearer {token}\"\r\n         self.session.headers.update(headers)\r\n \r\n+    # --- Internal helpers ---\r\n+    def _sleep_backoff(self, attempt: int) -> None:\r\n+        if self._backoff_factor <= 0:\r\n+            return\r\n+        delay = self._backoff_factor * (2 ** (attempt - 1))\r\n+        time.sleep(min(delay, 8.0))\r\n+\r\n+    def _should_retry(self, status_code: Optional[int], exc: Optional[Exception]) -> bool:\r\n+        if exc is not None:\r\n+            return isinstance(exc, (requests.Timeout, requests.ConnectionError))\r\n+        if status_code is None:\r\n+            "]
[0.714067, "o", "return False\r\n+        return status_code == 429 or 500 <= status_code < 600\r\n+\r\n+    def _post_graphql(self, payload: Dict[str, Any]) -> requests.Response:\r\n+        last_exc: Optional[requests.RequestException] = None\r\n+        last_resp: Optional[requests.Response] = None\r\n+        for attempt in range(1, self._max_retries + 1):\r\n+            try:\r\n+                resp = self.session.post(self.graphql_url, json=payload, timeout=30)\r\n+                last_resp = resp\r\n+                if not self._should_retry(resp.status_code, None):\r\n+                    return resp\r\n+            except requests.RequestException as e:\r\n+                last_exc = e\r\n+                if not self._should_retry(None, e):\r\n+                    raise\r\n+            if attempt < self._max_retries:\r\n+                self._sleep_backoff(attempt)\r\n+        if last_resp is not None:\r\n+            return last_resp\r\n+        assert last_exc is not None\r\n+        raise GitHubAPIError(f\"Request failed after {self._max_retries} retries:"]
[0.714151, "o", " {last_exc}\") from last_exc\r\n```\r\n\r\n### Comment\r\n![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\r\n\r\nThe introduction of retry logic with exponential backoff is a great improvement for the client's resilience.\r\n\r\nHowever, the implementation of `_post_graphql` could be simplified for better clarity and maintainability. Currently, its failure handling is inconsistent:\r\n*   It raises a `GitHubAPIError` directly if retries are exhausted due to network exceptions (e.g., `ConnectionError`).\r\n*   It returns the final failed `requests.Response` object if retries are exhausted due to retryable HTTP status codes (e.g., 5xx errors), leaving it to the caller to handle.\r\n\r\nThis split responsibility can make the code harder to reason about. A clearer approach would be for this function to always raise an exception after exhausting all retries, centralizing the failure logic. This would also remove the need for the `assert last_exc is not None` check.\r\n\r\n```python\r\ndef _post_graphql(self, payload: Dict"]
[0.714188, "o", "[str, Any]) -> requests.Response:\r\n    last_exc: Optional[Exception] = None\r\n    for attempt in range(1, self._max_retries + 1):\r\n        try:\r\n            resp = self.session.post(self.graphql_url, json=payload, timeout=30)\r\n            if not self._should_retry(resp.status_code, None):\r\n                return resp  # Success or non-retryable error\r\n            last_exc = GitHubAPIError(f\"Attempt {attempt} failed with status {resp.status_code}\")\r\n        except requests.RequestException as e:\r\n            if not self._should_retry(None, e):\r\n                raise  # Non-retryable network error\r\n            last_exc = e\r\n\r\n        if attempt < self._max_retries:\r\n            self._sleep_backoff(attempt)\r\n\r\n    # If the loop completes, all retries have been exhausted.\r\n    raise GitHubAPIError(f\"Request failed after {self._max_retries} retries\") from last_exc\r\n```\r\n\r\n---\r\n"]
